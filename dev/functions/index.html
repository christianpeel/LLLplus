<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · LLLplus.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="LLLplus.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LLLplus.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/christianpeel/LLLplus.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="LLLplus.lll" href="#LLLplus.lll"><code>LLLplus.lll</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">B,T,Q,R = lll(H,δ=3/4)</code></pre><p>Do Lenstra–Lenstra–Lovász lattice reduction of matrix <code>H</code> using optional parameter <code>δ</code>.  The output is <code>B</code>, an LLL-reduced basis; <code>T</code>, a unimodular (meaning <code>det(T)=+/-1</code>) transformation matrix such that <code>B= H*T</code>; and finally <code>Q</code> and <code>R</code> which are a QR decomposition of <code>B</code>.  So <code>H = B*inv(T) = Q*R*inv(T)</code>.</p><p>Follows D. Wuebben, et al, &quot;Lattice Reduction - A Survey with Applications in Wireless Communications&quot;, IEEE Signal Processing Magazine, Apr 2011.  http://www.ant.uni-bremen.de/sixcms/media.php/102/10740/SPM<em>2011</em>Wuebben.pdf</p><p>The LLL tecnique was originally described in &quot;Factoring polynomials with rational coefficients&quot; by A. K. Lenstra, H. W. Lenstra Jr. and L. Lovász, Mathematische Annalen 261, 1982. http://ftp.cs.elte.hu/~lovasz/scans/lll.pdf</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];B,_ = lll(H); B
2×2 Matrix{Int64}:
 1  -1
 1   1

julia&gt; H= BigFloat.([1.5 2; 3 4]) .+ 2im; B,_= lll(H); B
2×2 Matrix{Complex{BigFloat}}:
 0.5+0.0im  0.0+1.0im
 1.0+0.0im  0.0+0.0im

julia&gt; N=500;H = randn(N,N); B,T = lll(H);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/lll.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.cvp" href="#LLLplus.cvp"><code>LLLplus.cvp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x=cvp(y,R::UpperTriangular)</code></pre><p>Solve the problem <code>argmin_x ||y-Rx||</code> for integer x using the technique from the paper below. The input vector <code>y</code> is of length <code>n</code>, with upper triangular <code>R</code> of dimension <code>n</code> by <code>n</code>, and the returned vector <code>x</code> of length <code>n</code>.</p><pre><code class="nohighlight hljs">x=cvp(y,R,infinite=Val(true),Umin=-1,Umax=-Umin,nxMax=Int(ceil(log2(n)*1e6)))</code></pre><p>If <code>infinite==Val(true)</code> then we search the (infinite) lattice, otherwise we search integers in <code>[Umin,Umax]</code>. When <code>nxMax</code> is included, it gives a maximum number of steps to take, otherwise a heuristic value is used. Note that <code>cvp</code> does not handle complex numbers.</p><p>Follows &quot;Faster Recursions in Sphere Decoding&quot; Arash Ghasemmehdi, Erik Agrell, IEEE Transactions on Information Theory, vol 57, issue 6 , June 2011.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H=[1 2; 3 4]; Q,R=qr(H); uhat = cvp(Q&#39;*[0,2],UpperTriangular(R))
2-element Vector{Float64}:
  2.0
 -1.0

julia&gt; uhat = cvp(Q&#39;*[0,2],UpperTriangular(R),Val(false),0,100)
2-element Vector{Float64}:
 1.0
 0.0

julia&gt; n=100;H=randn(n,n); Q,Rt=qr(H); R=UpperTriangular(Rt);

julia&gt; u=Int.(rand(0:1e10,n));y=H*u+rand(n)/100;

julia&gt; uhat=cvp(Q&#39;*y,R); sum(abs.(u-uhat))
0.0

julia&gt; n=500;H=randn(n,n); Q,Rt=qr(H); R=UpperTriangular(Rt);

julia&gt; u=Int.(rand([-1,1],n));y=H*u+rand(n)/100;

julia&gt; uhat=cvp(Q&#39;*y,R,Val(false),-1,1); sum(abs.(u-uhat))
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/cvp.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.svp" href="#LLLplus.svp"><code>LLLplus.svp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x=svp(B)</code></pre><p>Find the shortest basis vector <code>b</code> for the lattice formed by the matrix <code>B</code>. This solves the &#39;shortest vector problem&#39; (SVP). Note that <code>svp</code> does not handle complex numbers.</p><p>Follows &quot;Algorithm SHORTESTVECTOR(G)&quot; from &quot;Closest Point Search in Lattices&quot; by Erik Agrell, Thomas Eriksson, Alexander Vardy, and Kenneth Zeger in IEEE Transactions on Information Theory, vol. 48, no. 8, August 2002.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H=[1 2; 3 4]; svp(H)
2-element Vector{Int64}:
 -1
 -1

julia&gt; H = [1 0 0 0;   0 1 0 0;   208 175 663 0;     651 479 0  663];

julia&gt; svp(H)
4-element Vector{Int64}:
  16
 -19
   3
 -11
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/cvp.jl#L150-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.brun" href="#LLLplus.brun"><code>LLLplus.brun</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">B, T = brun(H)</code></pre><p>Brun&#39;s integer-relations alg implemented as a matrix decomposition. Takes as input the matrix <code>H</code> and returns a reduced basis <code>B</code> and <code>T</code>, a unimodular transformation matrix such that <code>B = H*T</code>. Brun reduction is often done with <code>pinv(H)</code> as input to yield <code>B = pinv(H)*T</code>.</p><p>See V. Brun, &quot;En generalisation av kjedebrøken I,&quot; Skr. Vid ensk. Selsk. Kristiana, Mat. Nat. Klasse, 1919.  See https://archive.org/stream/skrifterutgitavv201chri#page/300/mode/2up</p><p>Follows code from D. Wuebben, D. Seethaler, J. Jalden, and G. Matz, &quot;Lattice Reduction - A Survey with Applications in Wireless Communications&quot; IEEE Signal Processing Magazine, March 2011</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H=[1 2; 3 4]; B,T=brun(H); T
2×2 Matrix{Int64}:
  3  -1
 -2   1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/brun.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.gauss" href="#LLLplus.gauss"><code>LLLplus.gauss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">B = gauss(H)</code></pre><p>Do Gauss/Lagrange reduction on the lattice defined by the two columns of H.</p><p>Follows Fig 2.3 of &quot;Lattice Basis Reduction: An Introduction to the LLL Algorithm and Its Applications&quot; by Murray R. Bremner, CRC Press, 2012.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H = [1 2; 3 3]; B = gauss(H)
2×2 Matrix{Float64}:
 1.0  0.0
 0.0  3.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/lll.jl#L105-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.seysen" href="#LLLplus.seysen"><code>LLLplus.seysen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">B,T,B_dual,num_it = seysen(H::Array{Td,2}) where Td</code></pre><p>Do greedy  Seysen lattice reduction  on the  matrix <code>H</code>, returning  <code>B</code>, the reduced lattice basis;  <code>T</code> a unimodular matrix that reduces  <code>H</code> (i.e. <code>B = H*T</code>); <code>B_dual</code>, dual lattice basis (i.e., <code>B_dual = pinv(B)</code>); and num_it the number of iterations (basis updates). See also <a href="#LLLplus.lll"><code>lll</code></a>.</p><p>Follows Seysen algorithm in &quot;Lattice Reduction - A Survey with Applications in Wireless Communications&quot; by D. Wuebben, et al, IEEE Signal Processing Magazine, 2011.</p><p>Technique originally described in &quot;Simultaneous reduction of a lattice basis and its reciprocal basis&quot; by M. Seysen, Combinatorica, 1993. http://link.springer.com/article/10.1007%2FBF01202355</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];B,T = seysen(H); B
2×2 Matrix{Int64}:
 -1  1
  1  1

julia&gt; H= BigFloat.([1.5 2; 3 4]) .+ 2im; B,_= seysen(H); B
2×2 Matrix{Complex{BigFloat}}:
 0.0+1.0im  0.5+0.0im
 0.0+0.0im  1.0+0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/seysen.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.vblast" href="#LLLplus.vblast"><code>LLLplus.vblast</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">W,P,B = vblast(H)</code></pre><p>Find a VBLAST decomposition of <code>H</code> such that <code>H = pinv(W)*B*P&#39;</code> or <code>B = W*H*P</code>.  Here <code>P</code> is a permutation matrix, <code>B</code> is lower triangular with ones on the diagonal, and <code>W</code> has orthogonal rows.</p><pre><code class="nohighlight hljs">W,P,B = vblast(H,mu)</code></pre><p>If an SNR argument <code>mu</code> is passed in, a regularized (&quot;MMSE&quot;) decomposition is done, with the result that <code>W</code> will no longer have orthogonal rows and <code>B</code> is no longer lower triangular.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1. 2; 3 4];W,_ = vblast(H); W
2×2 Matrix{Float64}:
 1.5  -0.5
 0.1   0.3

julia&gt; H= BigFloat.([1.5 2; 3 4]) .+ 2im; W,_= vblast(H); W
2×2 Matrix{Complex{BigFloat}}:
      -2.0+3.0im            2.0-1.5im     
 0.0779221-0.103896im  0.155844-0.103896im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/vblast.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.subsetsum" href="#LLLplus.subsetsum"><code>LLLplus.subsetsum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x = subsetsum(a,s)</code></pre><p>For a vector of integers <code>a</code>, and an integer <code>s</code>, try to find a binary vector <code>x</code> such that <code>x&#39;*a=s</code>. We use the LLL algorithm to find the solution. This is not a robust tool, just a demo.</p><p>This function tries first the technique in the <code>lagariasodlyzko</code> function, and if it fails, a solution via <code>mdsubsetsum</code> is attempted.</p><p>It appears that this function can also solve some integer relations problems. See the first example.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a=[1.5;.5;0;.1;.2]; s=2.2; x,_=subsetsum(a,s,true); s-x&#39;*a
A binary Lagarias-Odlyzko solution was found.
A solution was found via lagariasodlyzko
0.0

julia&gt; a=[32771,65543,131101,262187,524387,1048759, # from Bremner p 117
          2097523,4195057,8390143,16780259,33560539,
          67121039,134242091,268484171,536968403];

julia&gt; s=891221976; x,_=subsetsum(a,s,false); s-x&#39;*a
0.0

julia&gt; N=40;a=rand(1:2^BigInt(256),N);xtrue=rand(Bool,N); s=a&#39;*xtrue; 

julia&gt; setprecision(BigFloat,300); x,_=subsetsum(a,s,false); s-x&#39;*a
0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/applications.jl#L75-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.lagariasodlyzko" href="#LLLplus.lagariasodlyzko"><code>LLLplus.lagariasodlyzko</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x = lagariasodlyzko(a,s)</code></pre><p>For a vector of integers <code>a</code>, and an integer <code>s</code>, try to find a binary vector <code>x</code> such that <code>x&#39;*a=s</code>. We use the LLL algorithm to find the solution. This is not a robust tool, just a demo.</p><p>This follows the technique described by Lagarias and Odlyzko  in  &quot;Solving Low-Density Subset Sum Problems&quot;  in Journal of ACM, Jan 1985. Code based on http://web.eecs.umich.edu/~cpeikert/lic15/lec05.pdf We can likely get better results using techniques described and referenced in https://www-almasty.lip6.fr/~joux/pages/papers/ToolBox.pdf</p><p>It&#39;s odd that permuting the <code>a</code> vector in the second example given below causes the alg to often not find a binary solution. Apparently this is a common oddity with lattice solvers.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a=[1.5;.5;0;.1;.2]; s=2.2; x,_=lagariasodlyzko(a,s); s-x&#39;*a
0.0

julia&gt; a=[32771,65543,131101,262187,524387,1048759, # from Bremner p 117
          2097523,4195057,8390143,16780259,33560539,
          67121039,134242091,268484171,536968403];

julia&gt; s=891221976; x,_=lagariasodlyzko(a,s); s-x&#39;*a
0.0

julia&gt; N=40;a=rand(1:2^BigInt(256),N);xtrue=rand(Bool,N); s=a&#39;*xtrue; 

julia&gt; setprecision(BigFloat,300); x,_=lagariasodlyzko(a,s); s-x&#39;*a
0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/applications.jl#L128-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.mdsubsetsum" href="#LLLplus.mdsubsetsum"><code>LLLplus.mdsubsetsum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x = mdsubsetsum(a,sM,ratio=.5,Kpm=3)</code></pre><p>For a vector of integers <code>a</code>, and an integer <code>sM</code>, try to find a binary vector <code>x</code> such that <code>x&#39;*a=s</code> using the technique from &quot;Multidimensional subset sum problem&quot; [1][2]. A major goal of the technique is to solve problems in which there are about 50% ones in <code>x</code>; other ratios of ones to zeros can be specified in <code>ratio</code>.  The thesis also suggests searching <code>Kpm=3</code> values around the nominal k. This technique is related to that in <a href="#LLLplus.subsetsum"><code>subsetsum</code></a> in that both use the LLL algorithm.  This is not a robust tool, just a demo.</p><p>[1] https://scholarworks.rit.edu/theses/64/</p><p>[2] https://pdfs.semanticscholar.org/21a7/c2f9ff29507f1153aefcca04d1cd308e45c0.pdf</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random, LLLplus

julia&gt; a=[1.5;.5;0;.1;.2]; s=2.2; x=mdsubsetsum(a,s); s-x&#39;*a
0.0

julia&gt; a=[32771,65543,131101,262187,524387,1048759, # from Bremner p 117
          2097523,4195057,8390143,16780259,33560539,
          67121039,134242091,268484171,536968403];

julia&gt; sM=891221976; x=mdsubsetsum(a,sM); sM-x&#39;*a
0

julia&gt; setprecision(BigFloat,300); Random.seed!(0);

julia&gt; N=40;a=rand(1:2^BigInt(256),N);xtrue=rand(Bool,N); s=a&#39;*xtrue;

julia&gt; x=mdsubsetsum(a,s); s-x&#39;*a
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/applications.jl#L244-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.integerfeasibility" href="#LLLplus.integerfeasibility"><code>LLLplus.integerfeasibility</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integerfeasibility(A,d)</code></pre><p>Given a linear system <code>Ax=d</code>, return an integer vector <code>x</code> which satisfies the system.</p><pre><code class="nohighlight hljs">integerfeasibility(A,d,true)</code></pre><p>If the third argument is present and is <code>true</code>, then as well as returning a solution <code>x</code>, also return a matrix <code>xNull</code> of vectors in the null space of <code>A</code> which could be added to the <code>x</code> vector to find a solution which satisfies a constraint such as <code>0 .≤ x .≤ u</code>; see the paper below.</p><p>This is not a robust tool, just a demo.</p><p>&quot;Solving A System Of Diophantine Equations With Bounds On The Variables&quot; by Karen Aardal, Cor Hurkens, and Arjen Lenstra in Integer Programming and Combinatorial Optimization, 6th International IPCO Conference, vol 1412, pp 229-242, 1998. See http://softlib.rice.edu/pub/CRPC-TRs/reports/CRPC-TR98782.pdf</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A=[10 1 -9; 1 8 8]; xtrue=[0; 2; 9]; d=A*xtrue;

julia&gt; integerfeasibility(A,d)
3-element Vector{Int64}:
 0
 2
 9

julia&gt; A=[10 1.1 -9.1; 1 8 8]; d=A*xtrue;

julia&gt; integerfeasibility(A,d)
3-element Vector{Float64}:
 0.0
 2.0
 9.0

julia&gt; n=20;m=30; A = rand(-10:10,n,m); xtrue = rand(0:10,m); d=A*xtrue;

julia&gt; sum(abs.(xtrue - integerfeasibility(A,d) ))
0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/applications.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.rationalapprox" href="#LLLplus.rationalapprox"><code>LLLplus.rationalapprox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rationalapprox(x::AbstractArray{&lt;:Real,1},M,Ti=BigInt,verbose=false)</code></pre><p>For a vector of Reals <code>x</code>, and an integer <code>M</code>, find an integer q such that <code>maximum(abs.(x*q-round.(x*q)))</code> is small; the vector <code>x</code> is approximated by <code>round.(x*q)//q</code>.  The integer <code>q</code> is less than or equal to <code>M</code> and the approximation satisfies <code>max(abs.(x*q-round.(x*q)))≤sqrt(5)*2^(n/4 - 5)*M^(-1/n)</code>; this equation comes from the paper below.  The LLL algorithm reduction is used to find the solution. The approximation vector is returned. This is also known as &quot;simultaneous diophantine approximation&quot;; see for example the title of the Hanrot paper below.</p><p>This is not a robust tool, just a demo.</p><p>&quot;LLL: A Tool for Effective Diophantine Approximation&quot; by Guillaume Hanrot in the book &quot;The LLL Algorithm: Survey and Applications&quot; edited by Phong Q. Nguyen and Brigitte Vallée, Springer, Heidelberg, 2010.</p><p>See also Chapter 9 of M. R. Bremner, &quot;Lattice Basis Reduction: An Introduction to the LLL Algorithm and Its Applications&quot; CRC Press, 2012.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [0.3912641745333527; 0.5455179974014548; 0.1908698210882469];

julia&gt; rationalapprox(x,1e4,Int64)
3-element Vector{Rational{Int64}}:
 43//110
  6//11
 21//110
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/applications.jl#L319-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.spigotBBP" href="#LLLplus.spigotBBP"><code>LLLplus.spigotBBP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spigotBBP(α::Td,s,b,n,K,verbose=false) where {Td}</code></pre><p>Check for a BBP-style [1] infinite series for the constant <code>α</code>.  These are &quot;spigot&quot; formulas that can be used to generate (for example) the millionth digit of the constant <code>α</code> without learning the previous digits. Specifically, given the constant <code>α</code>, and parameters <code>b</code>, <code>n</code>, and <code>s</code>, look for a vector of numbers <code>a_1</code> through <code>a_n</code> that satisfies the following equation:</p><p><span>$\alpha= \sum_{k=0}^\infty \frac{1}{b^k} \left( \frac{a_1}{(nk+1)^s} + \ldots + \frac{a_n}{(nk+n)^s} \right)$</span></p><p>Because it&#39;s hard to sum to infinity, the sum is stopped at K. If a formula is found, it is printed to the screen in LaTeX and the coefficents <code>a</code> are returned as a vector.  An online LaTeX viewer such as https://www.latex4technics.com/ may be helpful.</p><p>This is not a robust tool, just a demo. For example, there may be a  problem with s≥2. See [2] for derivation of the technique used, and to  check whether a formula you find is new.</p><p>[1] David Bailey, Peter Borwein, and Simon Plouffe. &quot;On the rapid computation of various polylogarithmic constants.&quot; Mathematics of Computation 66.218 (1997): 903-913. https://www.ams.org/journals/mcom/1997-66-218/S0025-5718-97-00856-9/</p><p>[2] David Bailey, &quot;A Compendium of BBP-Type Formulas for Mathematical Constants&quot;. https://www.davidhbailey.com//dhbpapers/bbp-formulas.pdf</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spigotBBP(BigFloat(pi),1,16,8,45,true);
A solution was found w error -4.728672e-60. In LaTeX form it is
\alpha= \sum_{k=0}^\infty \frac{1}{16^k} \left(\frac{4}{8k+1}-\frac{2}{8k+4}-\frac{1}{8k+5}-\frac{1}{8k+6}\right)</code></pre><p>Other examples without output:</p><pre><code class="language-julia hljs">spigotBBP(Float64(pi),1,-4,4,22,true);
spigotBBP(log(2),1,2,2,30,true);
spigotBBP(9*log(3),1,9,2,30,true);
spigotBBP(atan(2)*8,1,16,8,30,true);
spigotBBP(8*sqrt(2)*log(1+sqrt(2)),1,16,8,25,true);</code></pre><p>There is a formula for pi^2 which the following command should find, but it does not find it. In fact the technique doesn&#39;t seem to work at all for  s&gt;2; It&#39;s not obvious what the problem is</p><pre><code class="language-julia hljs">spigotBBP(BigFloat(pi)*pi,2,64,6,25,true);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/applications.jl#L416-L467">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.hkz" href="#LLLplus.hkz"><code>LLLplus.hkz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">B,T=hkz(H)</code></pre><p>Do Hermite-Korkine-Zolotarev (HKZ) reduction of the basis <code>H</code>, returning the reduced basis <code>B</code> and the unimodular rotation <code>T</code> such that B = H*T. HKZ reduction is sometimes called &quot;Hermite-Korkine-Zolotareff&quot; or &quot;Korkine-Zolotareff&quot; reduction.</p><p>Based on &quot;Practical HKZ and Minkowski Lattice Reduction Algorithms&quot; by Wen Zhang, Sanzheng Qiao, and Yimin Wei, 17 Aug. 2011. http://www.cas.mcmaster.ca/~qiao/publications/ZQW11.pdf</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H=[1 2; 3 4];

julia&gt; B,T= hkz(H); B
2×2 Matrix{Int64}:
  1  -1
 -1  -1

julia&gt; N=9; H=rand(0:10,N,N); B,_=hkz(H);

julia&gt; ishkzreduced(B)
true

julia&gt; A = [10.6347 -66.2715  9.3046 17.5349 24.9625 # From
                0     8.6759 -4.7536 -3.9379 -2.3318 # TransIT, v65,
                0        0    0.3876  0.1296 -0.2879 # n3, Mar 2019,
                0        0    0       0.0133 -0.0082 # p 1929.
                0        0    0       0       0.0015];

julia&gt; B,_= hkz(A); # our HKZ doesn&#39;t work well on A ...

julia&gt; ishkzreduced(B) # ...because A is ill-conditioned
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/hkz.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.ishkzreduced" href="#LLLplus.ishkzreduced"><code>LLLplus.ishkzreduced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ishkzreduced(B)</code></pre><p>Determine if the matrix B is Hermite-Korkine-Zolotarev (HKZ) reduced or not. See the <code>hkz</code> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];ishkzreduced(H)
false

julia&gt; B,_=hkz(H); ishkzreduced(B)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/hkz.jl#L169-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.issizereduced" href="#LLLplus.issizereduced"><code>LLLplus.issizereduced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">issizereduced(B)</code></pre><p>Determine if the matrix B is size reduced or not.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];issizereduced(H)
false

julia&gt; B,T = lll(H);issizereduced(B)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/utilities.jl#L117-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.islllreduced" href="#LLLplus.islllreduced"><code>LLLplus.islllreduced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">islllreduced(B)</code></pre><p>Determine if the matrix B is LLL reduced or not. See p 56 of Bremner for a definition. </p><p>M. R. Bremner, &quot;Lattice Basis Reduction: An Introduction to the LLL  Algorithm and Its Applications&quot; CRC Press, 2012.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];islllreduced(H)
false

julia&gt; B,T=lll(H);islllreduced(B)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/utilities.jl#L75-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.orthogonalitydefect" href="#LLLplus.orthogonalitydefect"><code>LLLplus.orthogonalitydefect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orthogonalitydefect(B)</code></pre><p>Find the orthogonality defect of the matrix B defined, for example, on page 2 of Bennet:</p><p>&quot;An Enumeration Technique for Lattice Basis Reduction&quot; Huck Bennet, 2 Nov</p><ol><li>https://web.eecs.umich.edu/~hdbco/publications/bases.pdf</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];B,T=lll(H);

julia&gt; [orthogonalitydefect(H) orthogonalitydefect(B)]
1×2 Matrix{Float64}:
 7.07107  1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/utilities.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.hermitefactor" href="#LLLplus.hermitefactor"><code>LLLplus.hermitefactor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hermitefactor(B)</code></pre><p>Find the Hermite factor of matrix B</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];hermitefactor(H)
1.5811388300841898
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/utilities.jl#L32-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.seysencond" href="#LLLplus.seysencond"><code>LLLplus.seysencond</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seysencond(B)</code></pre><p>Seysen condition number as on, for example, page 3 of Bennet </p><p><a href="http://users.eecs.northwestern.edu/~hbennett/publications/bases.pdf">Bennet</a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];seysencond(H)
2.8284271247461903
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/utilities.jl#L49-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LLLplus.gen_qary_b" href="#LLLplus.gen_qary_b"><code>LLLplus.gen_qary_b</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">b= gen_qary_b(T, d::Int,k::Int,b::Int)</code></pre><p>Generate a q-ary lattice given an element type <code>T</code>, dimension <code>d</code>, parameter <code>k</code>, and bit-depth <code>b</code>. Specifically, find a <code>d</code> by <code>d</code> matrix which has the block structure <code>[I zeros(T,k,d-k); H q*I]]</code>, where the <code>k</code> by <code>d-k</code> matrix H is sampled from <code>0:q-1</code> and q is sampled uniformly from <code>1:big(2)^b-1</code></p><p>These bases correspond to the SIS/LWE q-ary lattices; see D. Micciancio and O. Regev. Post-Quantum Cryptography. Chapter of Lattice-based Cryptography, 147-191 (2009) and latticegen in https://github.com/fplll/fplll</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; b=gen_qary_b(Int64,2,1,6)
2×2 Matrix{Int64}:
 1   0
 7  32
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/christianpeel/LLLplus.jl/blob/38e2e322260118fddb909eb3008217843b33f7e9/src/latticegen.jl#L17-L37">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 8 February 2022 03:26">Tuesday 8 February 2022</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
